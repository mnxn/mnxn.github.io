<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Max Lantas</title><link>https://mnxn.github.io/blog/</link><description>Recent content in Blogs on Max Lantas</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 20 Oct 2020 23:51:37 -0700</lastBuildDate><atom:link href="https://mnxn.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Js_of_ocaml in the VSCode OCaml Platform</title><link>https://mnxn.github.io/blog/ocaml/vscode-jsoo/</link><pubDate>Tue, 20 Oct 2020 23:51:37 -0700</pubDate><description>For about two weeks now, the published version of the VSCode OCaml Platform extension has had something special about it.
It is using Js_of_ocaml! This is the result of a month-long effort to switch the extension&amp;rsquo;s OCaml-to-JS compiler from BuckleScript to Js_of_ocaml.
In this post, I will describe the extension, explain the reasoning for switching to Js_of_ocaml, and go over some of the things I learned through the porting experience.</description><content:encoded><p>For about two weeks now, the published version of the<a href="https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform">VSCode OCaml Platform extension</a> has had something special about it.</p><p>It is using<a href="https://ocsigen.org/js_of_ocaml">Js_of_ocaml</a>! This is the result of a month-long effort to switch the extension&rsquo;s OCaml-to-JS compiler from BuckleScript to Js_of_ocaml.</p><p>In this post, I will describe the extension, explain the reasoning for switching to Js_of_ocaml, and go over some of the things I learned through the porting experience.</p><h2 id="the-ocaml-platform">The OCaml Platform</h2><p>The VSCode OCaml Platform extension is part of the larger<a href="https://www.youtube.com/watch?v=E8T_4zqWmq8">OCaml Platform</a>; it interacts directly with<a href="https://github.com/ocaml/ocaml-lsp/">OCaml-LSP</a>, an implementation of the<a href="https://microsoft.github.io/language-server-protocol">Language Server Protocol</a> for OCaml editor support. The OCaml-LSP language server provides editor features like code completion, go to definition, formatting with<a href="https://github.com/ocaml-ppx/ocamlformat">ocamlformat</a>, and error highlighting.</p><p>OCaml-LSP can be used from any editor that supports the protocol, but the VSCode extension provides additional features: managing different package manager sandboxes; syntax highlighting of many OCaml-related filetypes; and integration with VSCode tasks, snippets, and indentation rules.</p><p>Both the language server and VSCode extension are continuously tested to ensure compatibility for opam and esy on macOS, Linux, and<a href="https://github.com/ocamllabs/vscode-ocaml-platform#windows">even Windows</a>.</p><p>Making OCaml more accessible is a goal for these projects. Providing support for a popular cross-platform code editor and the widely supported language server protocol helps achieve that goal.</p><h2 id="bucklescript-vs-js_of_ocaml">BuckleScript vs. Js_of_ocaml</h2><p>BuckleScript and Js_of_ocaml are technologies that accomplish a similar goal: compiling OCaml to Javascript code. However, there are a few differences that made it worthwhile to switch to Js_of_ocaml.</p><p>The ways in which BuckleScript and Js_of_ocaml approach compiling to JS are notably different. BuckleScript compiles from an early intermediate representation of the OCaml compiler to generate small JS files for each OCaml module; this is effective but fixes the OCaml language to a certain version (4.06.1 at the time of writing). Js_of_ocaml takes a different approach and generates JS from OCaml bytecode, which is more stable across different versions of OCaml but might provide less information. Using Js_of_ocaml allows the VSCode extension to be built with a recent version of OCaml (4.11.1 right now).</p><p>BuckleScript has undergone a rebranding and it is now called<a href="https://rescript-lang.org/">ReScript</a> with the addition of a new syntax. At one point, OCaml documentation was<a href="https://discuss.ocaml.org/t/where-do-i-look-for-docs-now-that-bucklescript-is-gone/6283">removed from the website</a>. As I revisit the site today, OCaml documentation has returned in the old v8.0.0 documentation as &ldquo;Older Syntax&rdquo;. It does seem that OCaml and ReasonML will be technically supported for now (forever?), but the project feels more distant from OCaml than it did as BuckleScript.</p><p>Js_of_ocaml, on the other hand, is deeply integrated with the OCaml language and ecosystem. This integration is great for existing OCaml developers because it means complex JS projects can be built with the excellent<a href="https://github.com/ocaml/dune">dune</a> build system with access to most of the same opam packages as native projects.</p><p>For a more in-depth comparison of the two technologies, I recommend reading<a href="https://github.com/jchavarri">@jchavarri</a>&rsquo;s<a href="https://www.javierchavarri.com/js_of_ocaml-and-bucklescript/">post about the topic</a>.</p><h2 id="gen_js_api">gen_js_api</h2><p>For a VSCode extension, there are many bindings that have to be created for interaction with the VSCode extension API. For the BuckleScript version of the extension, we used the built-in syntax for bindings.</p><p>For example, to bind to<a href="https://code.visualstudio.com/api/references/vscode-api#window.createOutputChannel"><code>vscode.window.createOutputChannel</code></a> in BuckleScript:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">external</span> createOutputChannel<span style="color:#f92672">:</span> name<span style="color:#f92672">:</span><span style="color:#66d9ef">string</span><span style="color:#f92672">-></span> OutputChannel.t<span style="color:#f92672">=</span><span style="color:#e6db74">"createOutputChannel"</span><span style="color:#f92672">[@@</span>bs<span style="color:#f92672">.</span><span style="color:#66d9ef">module</span><span style="color:#e6db74">"vscode"</span><span style="color:#f92672">]</span><span style="color:#f92672">[@@</span>bs<span style="color:#f92672">.</span>scope<span style="color:#e6db74">"window"</span><span style="color:#f92672">]</span></code></pre></div><p>This expresses that<code>createOutputChannel</code> is a function from the<code>window</code> namespace of the<code>vscode</code> node module. The<code>bs.module</code> annotation automatically inserts the<code>require</code> for the<code>vscode</code> module in the generated JavaScript.</p><p>There are a few ways to express the same things in Js_of_ocaml. The first is to use the provided functions in the<code>Js_of_ocaml.Js</code> module to manually convert between OCaml and JS types:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> createOutputChannel<span style="color:#f92672">~</span>name<span style="color:#f92672">=</span>
Js.Unsafe.global<span style="color:#f92672">##.</span>vscode<span style="color:#f92672">##.</span>window<span style="color:#f92672">##</span>createOutputChannel<span style="color:#f92672">[|</span> Js.string name<span style="color:#f92672">|]</span></code></pre></div><p>Notice that certain OCaml types (like strings) have to be converted into their JS representation. Doing these conversions manually may work for small libraries, but it would be impractical to do that for every binding and type in the expansive VSCode API.</p><p>For that reason,<a href="https://github.com/LexiFi/gen_js_api">gen_js_api</a> is a great alternative. The same binding with gen_js_api looks like this:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span> createOutputChannel<span style="color:#f92672">:</span> name<span style="color:#f92672">:</span><span style="color:#66d9ef">string</span><span style="color:#f92672">-></span> OutputChannel.t<span style="color:#f92672">[@@</span>js<span style="color:#f92672">.</span>global<span style="color:#e6db74">"vscode.window.createOutputChannel"</span><span style="color:#f92672">]</span></code></pre></div><p>What gen_js_api will do is generate code that automatically calls<code>Ojs.string_to_js</code> for the parameter and<code>OutputChannel.t_of_js</code> for the return value. An OCaml value can be converted a JS value if it is a<a href="https://github.com/LexiFi/gen_js_api/blob/master/TYPES.md">&ldquo;JS-able&rdquo;</a> type, or if the appropriate<code>of_js</code>/<code>to_js</code> functions exist.</p><p>It is important to note that unlike BuckleScript, gen_js_api is actually doing a conversion between values. If a function binding is written that returns an OCaml record, modifying a field of that record only modifies the record itself; the original JS value is untouched. This is different from BuckleScript, where an OCaml type directly corresponding to its JS data representation.</p><p>To avoid this, it is possible to keep values as an abstract<code>Ojs.t</code> type, which are the unconverted JS values. Accessing and setting fields can be done with a function annotated with<a href="https://github.com/LexiFi/gen_js_api/blob/master/VALUES.md"><code>[@@js.set]</code> or<code>[@@js.get]</code></a>. This method was used for the entirety of the extension&rsquo;s VSCode bindings, which can be found<a href="https://github.com/ocamllabs/vscode-ocaml-platform/tree/master/vscode">here</a>.</p><h2 id="node-modules">Node Modules</h2><p>As mentioned previously, BuckleScript provides a way to reference Node modules with<code>[@@bs.module]</code>. As far as I know, there is no simple equivalent provided by Js_of_ocaml or gen_js_api at the moment. Fortunately, there is a simple workaround with a single JS stub file:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">joo_global_object</span>.<span style="color:#a6e22e">vscode</span><span style="color:#f92672">=</span><span style="color:#a6e22e">require</span>(<span style="color:#e6db74">"vscode"</span>);</code></pre></div><p>In this JavaScript file,<code>joo_global_object</code> refers to the same value as<code>Js.Unsafe.global</code>. Setting the<code>vscode</code> field this way allows it to be referenced by the gen_js_api functions globally.</p><p>For this JavaScript file to be used, the library&rsquo;s dune configuration must be updated with:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">(js_of_ocaml (javascript_files vscode_stub.js))</code></pre></div><p>Afterward, bindings can be created that reference<code>vscode</code> and its namespaces or values.</p><p>There is some<a href="https://github.com/LexiFi/gen_js_api/pull/119">ongoing work</a> in gen_js_api that may improve the interaction between node modules and scopes.</p><h2 id="json">JSON</h2><p>JSON is a staple of many browser and node.js projects; the VSCode extension is no different. In the extension, JSON is used to (de)serialize user settings and interact with the language server using JSON-RPC.</p><p>When the extension was built with BuckleScript, it used<a href="https://github.com/glennsl">@glennsl</a>&rsquo;s<a href="https://github.com/glennsl/bs-json">bs-json</a> library for composable encoding and decoding functions. bs-json wasn&rsquo;t available for Js_of_ocaml, so I decided to reimplement it for Js_of_ocaml as<a href="https://github.com/mnxn/jsonoo">jsonoo</a> (<a href="https://opam.ocaml.org/packages/jsonoo/">opam</a>). The documentation for jsonoo is available<a href="https://github.com/mnxn/jsonoo">here</a>.</p><p>The main idea is that there are<code>decoder</code> and<code>encoder</code> types which are<code>Jsonoo.t -> 'a</code> and<code>'a -> Jsonoo.t</code> function types, respectively. The functions provided by jsonoo can easily compose<code>decoder</code> or<code>encoder</code> functions to handle complex JSON values. The<code>Jsonoo.t</code> type is represented as a JS value and uses the Js_of_ocaml library to convert between OCaml values and JavaScript JSON values.</p><p>For example, to try to decode a list of integers, returning a default value otherwise:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> decode json<span style="color:#f92672">=</span><span style="color:#66d9ef">let</span><span style="color:#66d9ef">open</span> Jsonoo.<span style="color:#a6e22e">Decode</span><span style="color:#66d9ef">in</span>
try_default []<span style="color:#f92672">(</span><span style="color:#66d9ef">list</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span> json</code></pre></div><p>Since jsonoo provides<a href="https://mnxn.github.io/jsonoo/jsonoo/Jsonoo/index.html#compatibility-with-gen_js_api"><code>t_of_js</code> and<code>t_to_js</code> functions</a>, it is also possible to use the JSON type with gen_js_api bindings:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span> send_json<span style="color:#f92672">:</span> t<span style="color:#f92672">-></span> Jsonoo.t<span style="color:#f92672">-></span><span style="color:#66d9ef">unit</span><span style="color:#f92672">[@@</span>js<span style="color:#f92672">.</span>call<span style="color:#f92672">]</span></code></pre></div><p>jsonoo seems to work well for its purpose of a Js_of_ocaml JSON library, but<a href="https://github.com/rgrinberg/">@rgrinberg</a><a href="https://discuss.ocaml.org/t/ann-jsonoo-0-1-0/6480/4">brought up the point</a> that this fragments the JSON libraries based on their underlying JSON implementation. For that reason, it may be worthwhile to look into<a href="https://gitlab.com/nomadic-labs/json-data-encoding">json-data-encoding</a>, an alternative that allows using the same API across different JSON representations.</p><h2 id="promises">Promises</h2><p>As an extension that primarily operates on the user-interface level, asynchronous operations through the<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">JS Promise API</a> are very important for a smooth user experience. Creating bindings to the promise functions seems straightforward at first, but you will eventually find that JS promises have a soundness problem.</p><p>For example, with a direct binding to the<code>resolve</code> function, one would expect that for every value passed to the function it would return that value wrapped in a promise.</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span> resolve<span style="color:#f92672">:</span><span style="color:#66d9ef">'</span>a<span style="color:#f92672">-></span><span style="color:#66d9ef">'</span>a promise</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> x<span style="color:#f92672">:</span><span style="color:#66d9ef">int</span> promise<span style="color:#f92672">=</span> resolve 1<span style="color:#66d9ef">let</span> y<span style="color:#f92672">:</span><span style="color:#66d9ef">int</span> promise promise<span style="color:#f92672">=</span> resolve<span style="color:#f92672">(</span>resolve 2<span style="color:#f92672">)</span><span style="color:#75715e">(* flattened! *)</span></code></pre></div><p>Everything seems fine from the OCaml side, but it turns out that JavaScript automatically flattens nested promises by following the<code>then</code> function of any value that is passed to it. Even though<code>y</code> appears to have the<code>int promise promise</code> type, the JS representation will be flattened to<code>int promise</code>. This is obviously a bad sign because the type system is misrepresenting the data, which will surely result in nasty runtime errors.</p><p>So how do we prevent the promise functions from following a value&rsquo;s<code>then</code> functions? The solution is simple: ensure that the JS functions never receive values that have a<code>then</code> function in the first place.</p><p>Using a technique I first saw in<a href="https://github.com/aantron">@aantron</a>&rsquo;s<a href="https://github.com/aantron/promise">promise library</a> for BuckleScript, it is possible to check for values that have a<code>then</code> function and wrap them in an object to prevent the JS functions from calling it:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#a6e22e">IndirectPromise</span>(<span style="color:#a6e22e">promise</span>) {<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">underlying</span><span style="color:#f92672">=</span><span style="color:#a6e22e">promise</span>;
}<span style="color:#66d9ef">function</span><span style="color:#a6e22e">wrap</span>(<span style="color:#a6e22e">value</span>) {<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">value</span><span style="color:#f92672">!==</span><span style="color:#66d9ef">undefined</span><span style="color:#f92672">&amp;&amp;</span><span style="color:#a6e22e">value</span><span style="color:#f92672">!==</span><span style="color:#66d9ef">null</span><span style="color:#f92672">&amp;&amp;</span><span style="color:#66d9ef">typeof</span><span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span><span style="color:#f92672">===</span><span style="color:#e6db74">"function"</span>
) {<span style="color:#66d9ef">return</span><span style="color:#66d9ef">new</span><span style="color:#a6e22e">IndirectPromise</span>(<span style="color:#a6e22e">value</span>);
}<span style="color:#66d9ef">else</span> {<span style="color:#66d9ef">return</span><span style="color:#a6e22e">value</span>;
}
}<span style="color:#66d9ef">function</span><span style="color:#a6e22e">unwrap</span>(<span style="color:#a6e22e">value</span>) {<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">value</span><span style="color:#66d9ef">instanceof</span><span style="color:#a6e22e">IndirectPromise</span>) {<span style="color:#66d9ef">return</span><span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">underlying</span>;
}<span style="color:#66d9ef">else</span> {<span style="color:#66d9ef">return</span><span style="color:#a6e22e">value</span>;
}
}</code></pre></div><p>Calling<code>wrap</code> on every value that is passed to<code>Promise.resolve</code> and calling<code>unwrap</code> on every resolved (completed) value will make the behavior consistent. Doing the wrapping and unwrapping for each unsound promise function binding will result in an API that is suitable for type-safe usage.</p><p>The final product of these bindings is the<a href="https://github.com/mnxn/promise_jsoo">promise_jsoo</a> (<a href="https://opam.ocaml.org/packages/promise_jsoo/">opam</a>) library for Js_of_ocaml. It includes bindings for the majority of the JS API, as well as supplemental functions that make it easier to interoperate with OCaml. promise_jsoo provides the necessary functions to use it with gen_js_api. The documentation for promise_jsoo is available<a href="https://mnxn.github.io/promise_jsoo/promise_jsoo/Promise/index.html">here</a>.</p><p>As an added bonus, running an OCaml version of at least 4.08 (which wasn&rsquo;t possible with BuckleScript) allows using<a href="https://ocaml.org/releases/4.11/htmlman/bindingops.html">binding operators</a>:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span><span style="color:#66d9ef">let</span><span style="color:#f92672">*</span><span style="color:#f92672">:</span><span style="color:#66d9ef">'</span>a promise<span style="color:#f92672">-></span><span style="color:#f92672">(</span><span style="color:#66d9ef">'</span>a<span style="color:#f92672">-></span><span style="color:#66d9ef">'</span>b promise<span style="color:#f92672">)</span><span style="color:#f92672">-></span><span style="color:#66d9ef">'</span>b promise</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> async_function ()<span style="color:#f92672">:</span><span style="color:#66d9ef">int</span> promise<span style="color:#f92672">=</span><span style="color:#66d9ef">let</span><span style="color:#f92672">*</span> first_num<span style="color:#f92672">=</span> get_num ()<span style="color:#66d9ef">in</span><span style="color:#66d9ef">let</span><span style="color:#f92672">*</span> second_num<span style="color:#f92672">=</span> get_num ()<span style="color:#66d9ef">in</span>
async_calculation first_num second_num</code></pre></div><p>This syntax is reminiscent of<code>await</code> syntax in other languages and it is a good alternative to the previous style of monadic operators:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> async_function ()<span style="color:#f92672">:</span><span style="color:#66d9ef">int</span> promise<span style="color:#f92672">=</span>
get_num ()<span style="color:#f92672">>>=</span><span style="color:#66d9ef">fun</span> first_num<span style="color:#f92672">-></span>
get_num ()<span style="color:#f92672">>>=</span><span style="color:#66d9ef">fun</span> second_num<span style="color:#f92672">-></span>
async_calculation first_num second_num</code></pre></div><p>promise_jsoo has a comprehensive test suite that should give weight to its claims of type safety. It was difficult to find a testing library that would work for an asynchronous library in Js_of_ocaml, but I eventually found<a href="https://github.com/johnelse/ocaml-webtest">webtest</a> by<a href="https://github.com/johnelse">@johnelse</a>.</p><p>In the future, I&rsquo;d like to investigate giving types to promise rejections and providing a simple way to convert to<a href="https://github.com/janestreet/async">Async</a> or<a href="https://github.com/ocsigen/lwt">Lwt</a> types.</p><h2 id="sysunix">Sys.unix</h2><p>Apparently, the value of<code>Sys.unix</code> in Js_of_ocaml is always true. The system seems to be hardcoded in Js_of_ocaml&rsquo;s<a href="https://github.com/ocsigen/js_of_ocaml/blob/master/runtime/sys.js">JS runtime</a>, which caused problems for path handling with the<code>Filename</code> OCaml module on a certain operating system (sorry Windows users!).</p><p>I assume the reason for the hardcoded system is because of a lack of a good way to get the operating system across different runtimes (browser, node.js). The browser has user agents and node.js has<code>process.platform</code>, but not vice versa.</p><p>As a workaround, the VSCode extension just uses bindings to the node<a href="https://nodejs.org/api/path.html"><code>path</code> module</a> for proper cross-platform path handling since the extension already depends on node.js.</p><h2 id="closing">Closing</h2><p>Overall, I am very happy with the transition to Js_of_ocaml. The ability to use the same build system and packages for native and JS projects leads to a smooth and enjoyable development experience. I am still learning the quirks of the JS target, but for the most part, Js_of_ocaml<em>just works</em>.</p><p>The VSCode OCaml Platform is an actively developed project with numerous contributors, so please feel free to<a href="https://github.com/ocamllabs/vscode-ocaml-platform/issues">submit an issue</a> or<a href="https://github.com/ocamllabs/vscode-ocaml-platform/pulls">contribute a pull-request</a>.</p><p>If you have any questions or comments about this post, I can answer them on the<a href="https://discuss.ocaml.org/t/js-of-ocaml-in-the-vscode-ocaml-platform/6635">OCaml forum topic</a>.</p></content:encoded></item></channel></rss>